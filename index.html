<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BookVerse - Global Book Search & Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 400px; border-radius: 1rem; margin-top: 2rem; }
    .book-map { height: 300px; border-radius: 0.5rem; margin-top: 1rem; }
    .leaflet-popup-content-wrapper { font-family: 'Inter', sans-serif; }
    /* Skeleton */
    .skeleton { background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 37%, #f3f4f6 63%); background-size: 400% 100%; animation: shimmer 1.4s ease infinite; }
    @keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
    .skeleton-line { height: 14px; border-radius: 4px; margin-bottom: 8px; }
    /* Loading overlay */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.25);
      z-index: 60;
    }
    .spinner {
      width: 48px;
      height: 48px;
      border: 5px solid rgba(255,255,255,0.9);
      border-top-color: rgba(59,130,246,1);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Toast */
    #toast {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 0.6rem 1rem;
      border-radius: 6px;
      display: none;
      z-index: 80;
    }
    /* Author photo styles */
    .author-photo {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #e5e7eb;
      transition: all 0.3s ease;
    }
    .author-photo:hover {
      border-color: #3b82f6;
      transform: scale(1.05);
    }
    .author-photo-placeholder {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 2rem;
      font-weight: bold;
      border: 3px solid #e5e7eb;
      transition: all 0.3s ease;
    }
    
    .author-photo-placeholder:hover {
      transform: scale(1.05);
      border-color: #3b82f6;
    }

    /* Book cover styles */
    .book-cover {
      transition: transform 0.2s ease;
    }
    
    .book-cover:hover {
      transform: scale(1.05);
    }
    
    /* Section Loading Styles */
    .section-loading {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #6b7280;
      font-size: 0.875rem;
      margin-right: 0.5rem;
    }
    
    .section-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e5e7eb;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    /* Different spinner colors for different sections */
    .bg-green-50 .section-spinner {
      color: #16a34a;
    }
    
    .bg-blue-50 .section-spinner {
      color: #2563eb;
    }
    
    /* Skeleton loading styles */
    .skeleton-card {
      background: #f9fafb;
      border-radius: 0.5rem;
      padding: 1.5rem;
      margin-bottom: 1rem;
      border: 1px solid #e5e7eb;
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    
    .skeleton-line {
      height: 1rem;
      background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 37%, #f3f4f6 63%);
      background-size: 400% 100%;
      animation: shimmer 1.4s ease infinite;
      border-radius: 0.25rem;
      margin-bottom: 0.5rem;
    }
    
    .skeleton-line.short {
      width: 60%;
    }
    
    .skeleton-line.medium {
      width: 80%;
    }
    
    .skeleton-line:last-child {
      margin-bottom: 0;
    }
    
    .skeleton-cover {
      width: 8rem;
      height: 12rem;
      background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 37%, #f3f4f6 63%);
      background-size: 400% 100%;
      animation: shimmer 1.4s ease infinite;
      border-radius: 0.5rem;
      margin-right: 1.5rem;
      flex-shrink: 0;
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.7;
      }
    }

    /* Simple loading text */
    .loading-text {
      color: #6b7280;
      font-style: italic;
      padding: 1rem;
      text-align: center;
    }

    /* Accessibility improvements */
    .focus\:ring-3:focus {
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
    }
    
    .high-contrast {
      filter: contrast(120%);
    }
    
    /* Better focus indicators */
    button:focus,
    a:focus,
    select:focus,
    input:focus {
      outline: 3px solid #3b82f6;
      outline-offset: 2px;
    }
    
    /* Back to Top Button */
    #backToTop {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 3rem;
      height: 3rem;
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      transition: all 0.3s ease;
      z-index: 50;
    }
    
    #backToTop:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
    }
    
    #backToTop:active {
      transform: translateY(0);
    }

    /* Sticky Section Headers */
    .sticky-section {
      position: sticky;
      top: 0;
      z-index: 10;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.95);
      border-bottom: 1px solid #e5e7eb;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .sticky-section:hover {
      background: rgba(255, 255, 255, 0.98);
    }

    /* Sticky content container */
    .sticky-content {
      position: relative;
      z-index: 1;
    }

  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <main class="max-w-4xl mx-auto px-4 py-8" role="main">
    
    <!-- Main Search Interface -->
    <section class="mb-8" aria-label="Search interface">
      <!-- Page Title -->
      <div class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-900 mb-2">üìö BookVerse Global Book Search</h1>
        <p class="text-gray-600">Search books and authors across multiple libraries</p>
      </div>
      
      <!-- Search Controls -->
      <div class="bg-white rounded-lg shadow p-6 mb-6">
        <div class="flex gap-3 items-center mb-4">
          <div class="relative flex-1">
            <input id="searchBar" type="text" placeholder="search title or author" class="w-full p-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="Search" />
            <button id="clearSearch" type="button" title="Clear" class="absolute right-2 top-2 bg-gray-200 p-1 rounded hidden" aria-label="Clear search">Reset</button>
          </div>
          <button id="searchButton" type="button" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium" aria-label="Search">
            üîç Search
          </button>
        </div>
        <div id="resultCount" class="text-sm text-gray-600" aria-live="polite"></div>
      </div>
      
      <!-- Connected Libraries Section -->
      <div class="mb-4">
        <h2 class="text-xl font-semibold text-gray-800 text-center">Connected Libraries</h2>
      </div>
      
      <section id="map" class="overview-map mb-8" aria-label="Library locations map">
        <!-- Persistent overview map showing libraries -->
      </section>
      <!-- Combined Results Area -->
      <section id="resultContainer" role="region" aria-label="Search results" aria-live="polite"></section>

    </div>
    
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
      <div class="flex flex-col items-center">
        <div class="spinner"></div>
        <p class="text-white mt-3">Loading‚Ä¶</p>
      </div>
    </div>

  <div id="toast" role="status" aria-live="polite"></div>
  
  <!-- Back to Top Button -->
  <button id="backToTop" title="Back to Top" aria-label="Scroll back to top">‚Üë</button>
  </main>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // Global variables
  const resultContainer = document.getElementById('resultContainer');
  const searchBar = document.getElementById('searchBar');
  const resultCount = document.getElementById('resultCount');
  const clearSearchBtn = document.getElementById('clearSearch');
  const mapDiv = document.getElementById('map');
  
  // persistent overview map and per-result map instances
  let overviewMap = null;
  // per-result map instances stored by container id
  const mapsById = {};
  let marker;
  // simple cache for LoC holdings checks to avoid repeat network calls
  const holdingsCache = new Map();
  // hydrate cache from localStorage when available
  try {
    const stored = localStorage.getItem('bookverse_holdingsCache');
    if (stored) {
      const parsed = JSON.parse(stored);
      Object.keys(parsed).forEach(k => holdingsCache.set(k, parsed[k]));
    }
  } catch (e) { /* ignore */ }

  function persistHoldingsCache() {
    try { localStorage.setItem('bookverse_holdingsCache', JSON.stringify(Object.fromEntries(holdingsCache))); } catch (e) {}
  }













    // Library of Congress coordinates
    const locLibrary = {
      name: 'Library of Congress',
      lat: 38.8887,
      lng: -77.0047,
      city: 'Washington DC',
      country: 'USA'
    };

    // Render a map inside a specific container (on-demand, per result)
    function showLoCMapAt(containerId, bookTitle) {
      const container = document.getElementById(containerId);
      if (!container) return;
      // remove existing map if present
      if (mapsById[containerId]) {
        try { mapsById[containerId].remove(); } catch (e) { /* ignore */ }
        delete mapsById[containerId];
      }

      try {
        const mapInstance = L.map(containerId).setView([locLibrary.lat, locLibrary.lng], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(mapInstance);
        L.marker([locLibrary.lat, locLibrary.lng])
          .addTo(mapInstance)
          .bindPopup(`<strong>${locLibrary.name}</strong><br>${locLibrary.city}, ${locLibrary.country}<br><em>${bookTitle}</em>`)
          .openPopup();
        mapsById[containerId] = mapInstance;
      } catch (err) {
        console.error('Error initializing map:', err);
        // clear the container to avoid leaving blank UI
        container.innerHTML = '<p class="text-red-600">Unable to load map.</p>';
      }
    }

    function closeMapById(containerId) {
      const container = document.getElementById(containerId);
      if (mapsById[containerId]) {
        try { mapsById[containerId].remove(); } catch (e) {}
        delete mapsById[containerId];
      }
      if (container) container.remove();
    }

    function closeAllMaps() {
      Object.keys(mapsById).forEach(id => {
        try { mapsById[id].remove(); } catch (e) {}
        delete mapsById[id];
      });
      // remove any stray inline map containers inside resultContainer
      Array.from(resultContainer.querySelectorAll('.map-wrapper')).forEach(n => n.remove());
    }

    // Initialize a persistent overview map at the top of the page
    function initOverviewMap() {
      const id = 'map';
      const el = document.getElementById(id);
      if (!el) return;
      // create a map only once
      if (overviewMap) try { overviewMap.remove(); } catch (e) {}
      try {
        overviewMap = L.map(id, { scrollWheelZoom: false }).setView([locLibrary.lat, locLibrary.lng], 4);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(overviewMap);
        L.marker([locLibrary.lat, locLibrary.lng])
          .addTo(overviewMap)
          .bindPopup(`<strong>${locLibrary.name}</strong><br>${locLibrary.city}, ${locLibrary.country}`);
      } catch (err) {
        console.error('Could not initialize overview map', err);
      }
    }

    // Check Library of Congress holdings using id.loc.gov when LCCN is available
    async function checkLoCHoldings(lccn) {
      if (!lccn) return 'no_lccn';
      // Use local proxy to avoid CORS issues
      const proxyUrl = `http://localhost:3000/loc/bib/${encodeURIComponent(lccn)}`;
      if (holdingsCache.has(lccn)) return holdingsCache.get(lccn);
      let status = 'unknown';
      try {
        const res = await fetch(proxyUrl, { headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
          status = (res.status === 404) ? 'not_found' : 'unknown';
        } else {
          const data = await res.json();
          status = (data && Object.keys(data).length > 0) ? 'found' : 'not_found';
        }
      } catch (err) {
        console.error('LoC holdings proxy check failed:', err);
        status = 'unknown';
      }
      try { holdingsCache.set(lccn, status); persistHoldingsCache(); } catch (e) {}
      return status;
    }

    // Initialize persistent overview map
    try { initOverviewMap(); } catch (e) { console.error(e); }

    function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text);
      } else {
        const el = document.createElement('textarea');
        el.value = text; document.body.appendChild(el); el.select(); document.execCommand('copy'); el.remove();
      }
    }

    // Enhanced author photo element with better image fetching
    function createAuthorPhotoElement(author) {
      const initial = (author.name || 'A').charAt(0).toUpperCase();

      // If author has photos array, use it
      if (author.photos && author.photos.length > 0) {
        const photoUrl = `https://covers.openlibrary.org/a/id/${author.photos[0]}-M.jpg`;
        return `<img src="${photoUrl}" class="author-photo" alt="${author.name || 'Author'}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="author-photo-placeholder" style="display: none;">${initial}</div>`;
      }

      // If author has an Open Library key, try to fetch photo from there
      if (author.key) {
        const authorId = author.key.replace('/authors/', '');
        const photoUrl = `https://covers.openlibrary.org/a/olid/${authorId}-M.jpg`;
        return `<img src="${photoUrl}" class="author-photo" alt="${author.name || 'Author'}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="author-photo-placeholder" style="display: none;">${initial}</div>`;
      }

      // Try to get photo using author name (last resort before initials)
      if (author.name) {
        const cleanName = author.name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        const photoUrl = `https://covers.openlibrary.org/a/name/${cleanName}-M.jpg`;
        return `<img src="${photoUrl}" class="author-photo" alt="${author.name || 'Author'}"
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="author-photo-placeholder" style="display: none;">${initial}</div>`;
      }

      // Fallback to initials
      return `<div class="author-photo-placeholder">${initial}</div>`;
    }

    // Function to enrich author data with additional details including photos
    async function enrichAuthorData(author) {
      if (!author.key) return author;

      try {
        const authorUrl = `https://openlibrary.org${author.key}.json`;
        const response = await fetch(authorUrl);
        if (!response.ok) return author;

        const authorDetails = await response.json();

        // Merge additional data
        return {
          ...author,
          photos: authorDetails.photos || author.photos,
          bio: authorDetails.bio || author.bio,
          wikipedia: authorDetails.wikipedia || author.wikipedia,
          links: authorDetails.links || author.links
        };
      } catch (error) {
        console.warn('Failed to enrich author data:', error);
        return author;
      }
    }

    function showToast(msg, ms = 2500) {
      const t = document.getElementById('toast');
      if (!t) return;
      t.textContent = msg; t.style.display = 'block';
      setTimeout(() => { t.style.display = 'none'; }, ms);
    }

    // Handle cover image loading errors with automatic fallback attempts
    function handleCoverError(img) {
      // Simple fallback: hide image and show placeholder
      img.style.display = 'none';
      if (img.nextElementSibling) {
        img.nextElementSibling.style.display = 'flex';
      }
    }

    // Debounced search helper
    function debounce(fn, ms = 450) {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    // Enhanced toggle handler for sticky sections
    function createToggleHandler(headerDiv, contentId) {
      return function() {
        const content = document.getElementById(contentId);
        const button = headerDiv.querySelector('button');

        if (content.style.display === 'none') {
          content.style.display = '';
          button.textContent = '‚àí';
          button.setAttribute('aria-label', 'Hide section');
          // Smooth scroll to show content when expanding
          setTimeout(() => {
            content.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 100);
        } else {
          content.style.display = 'none';
          button.textContent = '+';
          button.setAttribute('aria-label', 'Show section');
        }
      };
    }

    // Support Enter key to run the search immediately and use debounced change for typing
    const triggerSearch = () => searchBar.dispatchEvent(new Event('change'));
    searchBar.addEventListener('keydown', (e) => { if (e.key === 'Enter') triggerSearch(); });
    const debouncedTrigger = debounce(triggerSearch, 550);
    searchBar.addEventListener('input', () => {
      // show clear button when text exists
      if (searchBar.value.trim()) clearSearchBtn.classList.remove('hidden'); else clearSearchBtn.classList.add('hidden');
      debouncedTrigger();
    });
    clearSearchBtn.addEventListener('click', () => { searchBar.value = ''; searchBar.focus(); clearSearchBtn.classList.add('hidden'); triggerSearch(); });

    // Search button event listener
    document.getElementById('searchButton').addEventListener('click', () => {
      const searchBtn = document.getElementById('searchButton');
      const originalText = searchBtn.textContent;
      
      // Show loading state
      searchBtn.disabled = true;
      searchBtn.innerHTML = '<div class="flex items-center gap-2"><div class="section-spinner" style="width: 14px; height: 14px; border-width: 2px;"></div>Searching...</div>';
      
      // Reset button after search completes
      setTimeout(() => {
        searchBtn.disabled = false;
        searchBtn.innerHTML = originalText;
      }, 1000); // Minimum loading time for UX
      
      triggerSearch();
    });

    function showLoading() {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
      }
    }

    function hideLoading() {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    }

    searchBar.addEventListener('change', async () => {
      const query = searchBar.value.trim();
      // close any open per-result maps when running a new search
      closeAllMaps();
      if (!query) {
        resultContainer.innerHTML = '';
        return;
      }
      
      // Show loading immediately
      showLoading();
      
      try {
        // Always use 'all' mode - search all sources
        // Clear container once at the beginning
        resultContainer.innerHTML = '';
        
        // Create unified collapsible sections for all results
        
        // 1. Author Results Section
        const authorHeaderDiv = document.createElement('div');
        authorHeaderDiv.className = 'sticky-section bg-green-50 border-l-4 border-green-400 p-4 mb-4 cursor-pointer hover:bg-green-100 transition-colors';
        const authorContentId = `author-content-${Date.now()}`;
        authorHeaderDiv.innerHTML = `
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <h2 class="text-lg font-semibold text-green-800 mb-1">Open Library Author Results</h2>
              <p class="text-sm text-green-600">Authors from Open Library database <span id="author-status-${Date.now()}" class="text-xs text-gray-500"></span></p>
            </div>
            <div class="flex items-center gap-3">
              <div id="author-loading-${Date.now()}" class="section-loading" style="display: none;">
                <div class="section-spinner"></div>
                <span>Loading authors...</span>
              </div>
              <button class="text-green-600 hover:text-green-800 text-xl font-bold" aria-label="Click to expand section">+</button>
            </div>
          </div>
        `;
        
        const authorContentDiv = document.createElement('div');
        authorContentDiv.id = authorContentId;
        authorContentDiv.className = 'sticky-content author-results-content';
        authorContentDiv.style.display = 'none'; // Start collapsed
        
        // Add click handler for author toggle
        authorHeaderDiv.addEventListener('click', createToggleHandler(authorHeaderDiv, authorContentId));
        
        resultContainer.appendChild(authorHeaderDiv);
        resultContainer.appendChild(authorContentDiv);
        
        // 2. Open Library Title Results Section
        const olTitleHeaderDiv = document.createElement('div');
        olTitleHeaderDiv.className = 'sticky-section bg-green-50 border-l-4 border-green-400 p-4 mb-4 cursor-pointer hover:bg-green-100 transition-colors';
        const olTitleContentId = `ol-title-content-${Date.now()}`;
        olTitleHeaderDiv.innerHTML = `
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <h2 class="text-lg font-semibold text-green-800 mb-1">Open Library Title Results</h2>
              <p class="text-sm text-green-600">Book titles from Open Library database <span id="ol-title-status-${Date.now()}" class="text-xs text-gray-500"></span></p>
            </div>
            <div class="flex items-center gap-3">
              <div id="ol-title-loading-${Date.now()}" class="section-loading" style="display: none;">
                <div class="section-spinner"></div>
                <span>Loading titles...</span>
              </div>
              <button class="text-green-600 hover:text-green-800 text-xl font-bold" aria-label="Click to expand section">+</button>
            </div>
          </div>
        `;
        
        const olTitleContentDiv = document.createElement('div');
        olTitleContentDiv.id = olTitleContentId;
        olTitleContentDiv.className = 'sticky-content ol-title-results-content';
        olTitleContentDiv.style.display = 'none'; // Start collapsed
        
        // Add click handler for OL title toggle
        olTitleHeaderDiv.addEventListener('click', createToggleHandler(olTitleHeaderDiv, olTitleContentId));
        
        resultContainer.appendChild(olTitleHeaderDiv);
        resultContainer.appendChild(olTitleContentDiv);
        
        // 3. Library of Congress Results Section
        const locHeaderDiv = document.createElement('div');
        locHeaderDiv.className = 'sticky-section bg-blue-50 border-l-4 border-blue-400 p-4 mb-4 cursor-pointer hover:bg-blue-100 transition-colors';
        const locContentId = `loc-content-${Date.now()}`;
        locHeaderDiv.innerHTML = `
          <div class="flex items-center justify-between">
            <div class="flex-1">
              <h2 class="text-lg font-semibold text-blue-800 mb-1">Library of Congress Results</h2>
              <p class="text-sm text-blue-600">Direct from the Library of Congress catalog <span id="loc-status-${Date.now()}" class="text-xs text-gray-500"></span></p>
            </div>
            <div class="flex items-center gap-3">
              <div id="loc-loading-${Date.now()}" class="section-loading" style="display: none;">
                <div class="section-spinner"></div>
                <span>Loading LoC results...</span>
              </div>
              <button class="text-blue-600 hover:text-blue-800 text-xl font-bold" aria-label="Click to expand section">+</button>
            </div>
          </div>
        `;
        
        const locContentDiv = document.createElement('div');
        locContentDiv.id = locContentId;
        locContentDiv.className = 'sticky-content loc-results-content';
        locContentDiv.style.display = 'none'; // Start collapsed
        
        // Add click handler for LoC toggle
        locHeaderDiv.addEventListener('click', createToggleHandler(locHeaderDiv, locContentId));
        
        resultContainer.appendChild(locHeaderDiv);
        resultContainer.appendChild(locContentDiv);
        
        // Now run the searches with append mode and skip headers
        // Start all searches simultaneously for better performance
        
        // Show loading states for each section
        const authorLoadingId = `author-loading-${authorContentId.split('-').pop()}`;
        const olTitleLoadingId = `ol-title-loading-${olTitleContentId.split('-').pop()}`;
        const locLoadingId = `loc-loading-${locContentId.split('-').pop()}`;
        
        const authorLoading = document.getElementById(authorLoadingId);
        const olTitleLoading = document.getElementById(olTitleLoadingId);
        const locLoading = document.getElementById(locLoadingId);
        
        // Add skeleton loading to content areas
        authorContentDiv.innerHTML = `
          <div class="skeleton-card">
            <div class="flex items-start">
              <div class="skeleton-cover"></div>
              <div class="flex-1">
                <div class="skeleton-line"></div>
                <div class="skeleton-line medium"></div>
                <div class="skeleton-line short"></div>
                <div class="skeleton-line short"></div>
              </div>
            </div>
          </div>
          <div class="skeleton-card">
            <div class="flex items-start">
              <div class="skeleton-cover"></div>
              <div class="flex-1">
                <div class="skeleton-line"></div>
                <div class="skeleton-line medium"></div>
                <div class="skeleton-line short"></div>
              </div>
            </div>
          </div>
        `;
        
        olTitleContentDiv.innerHTML = `
          <div class="skeleton-card">
            <div class="flex items-start">
              <div class="skeleton-cover"></div>
              <div class="flex-1">
                <div class="skeleton-line"></div>
                <div class="skeleton-line medium"></div>
                <div class="skeleton-line short"></div>
                <div class="skeleton-line short"></div>
              </div>
            </div>
          </div>
        `;
        
        locContentDiv.innerHTML = `
          <div class="skeleton-card">
            <div class="flex items-start">
              <div class="skeleton-cover"></div>
              <div class="flex-1">
                <div class="skeleton-line"></div>
                <div class="skeleton-line medium"></div>
                <div class="skeleton-line short"></div>
                <div class="skeleton-line short"></div>
              </div>
            </div>
          </div>
          <div class="skeleton-card">
            <div class="flex items-start">
              <div class="skeleton-cover"></div>
              <div class="flex-1">
                <div class="skeleton-line"></div>
                <div class="skeleton-line medium"></div>
                <div class="skeleton-line short"></div>
              </div>
            </div>
          </div>
        `;
        
        // Show loading indicators
        if (authorLoading) authorLoading.style.display = 'flex';
        if (olTitleLoading) olTitleLoading.style.display = 'flex';
        if (locLoading) locLoading.style.display = 'flex';
        
        try {
          // Run author search
          const authorPromise = performAuthorSearch(query, { append: true, resultDiv: authorContentDiv, skipHeader: true })
            .finally(() => {
              if (authorLoading) authorLoading.style.display = 'none';
              // Add status indicator when loading is complete
              const statusElement = authorHeaderDiv.querySelector('[id^="author-status-"]');
              if (statusElement) {
                const count = authorContentDiv.children.length;
                statusElement.textContent = count > 0 ? `(${count} result${count === 1 ? '' : 's'} loaded - click + to view)` : '(no results found)';
                statusElement.className = count > 0 ? 'text-xs text-green-600 font-medium' : 'text-xs text-gray-500';
              }
            });
          
          // Run title search
          const titlePromise = performTitleSearch(query, olTitleContentDiv)
            .finally(() => {
              if (olTitleLoading) olTitleLoading.style.display = 'none';
              // Add status indicator when loading is complete
              const statusElement = olTitleHeaderDiv.querySelector('[id^="ol-title-status-"]');
              if (statusElement) {
                const count = olTitleContentDiv.children.length;
                statusElement.textContent = count > 0 ? `(${count} result${count === 1 ? '' : 's'} loaded - click + to view)` : '(no results found)';
                statusElement.className = count > 0 ? 'text-xs text-green-600 font-medium' : 'text-xs text-gray-500';
              }
            });
          
          // Run LoC search
          const locPromise = performLibraryOfCongressSearch(query, { append: true, resultDiv: locContentDiv, skipHeader: true })
            .finally(() => {
              if (locLoading) locLoading.style.display = 'none';
              // Add status indicator when loading is complete
              const statusElement = locHeaderDiv.querySelector('[id^="loc-status-"]');
              if (statusElement) {
                const count = locContentDiv.children.length;
                statusElement.textContent = count > 0 ? `(${count} result${count === 1 ? '' : 's'} loaded - click + to view)` : '(no results found)';
                statusElement.className = count > 0 ? 'text-xs text-blue-600 font-medium' : 'text-xs text-gray-500';
              }
            });
          
          // Wait for all searches to complete
          await Promise.allSettled([authorPromise, titlePromise, locPromise]);
          
          // Hide the global loading overlay after all searches complete
          hideLoading();
          
        } catch (searchErr) {
          console.error('Search error:', searchErr);
          // Hide all loading indicators on error
          if (authorLoading) authorLoading.style.display = 'none';
          if (olTitleLoading) olTitleLoading.style.display = 'none';
          if (locLoading) locLoading.style.display = 'none';
        }
        return;
      } catch (err) {
        console.error('Search error:', err);
        resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6"><p class="text-red-600">Search error: ${err.message}</p></div>`;
      }
      // end of change handler
    });

    // Helper function to calculate name similarity/relevance
    function calculateRelevance(authorName, searchQuery) {
      if (!authorName || !searchQuery) return 0;
      
      const author = authorName.toLowerCase().trim();
      const query = searchQuery.toLowerCase().trim();
      
      // Exact match gets highest score
      if (author === query) return 100;
      
      // Split names into words for better surname matching
      const authorWords = author.split(/\s+/).filter(word => word.length > 0);
      const queryWords = query.split(/\s+/).filter(word => word.length > 0);
      
      // Check if query matches any complete word in author name (great for surnames)
      let exactWordMatches = 0;
      queryWords.forEach(qWord => {
        if (authorWords.includes(qWord)) {
          exactWordMatches++;
        }
      });
      
      if (exactWordMatches === queryWords.length && exactWordMatches === authorWords.length) {
        return 95; // All words match exactly
      }
      if (exactWordMatches === queryWords.length) {
        return 85; // All query words found as complete words in author name
      }
      
      // Check if author name starts with the query (for "ernest hemingway" matching "ernest")
      if (author.startsWith(query)) return 80;
      
      // Check if any word in author name starts with query (for "hemingway" matching last name)
      let wordStartMatches = 0;
      queryWords.forEach(qWord => {
        if (authorWords.some(aWord => aWord.startsWith(qWord))) {
          wordStartMatches++;
        }
      });
      
      if (wordStartMatches === queryWords.length) return 75;
      if (wordStartMatches > 0) return 60 + (wordStartMatches / queryWords.length) * 15;
      
      // Check for partial word matches (surname fragments)
      let partialWordMatches = 0;
      queryWords.forEach(qWord => {
        if (qWord.length >= 3) { // Only check meaningful fragments
          authorWords.forEach(aWord => {
            if (aWord.includes(qWord) && aWord.length >= qWord.length) {
              partialWordMatches++;
            }
          });
        }
      });
      
      if (partialWordMatches >= queryWords.length) return 55;
      if (partialWordMatches > 0) return 45 + (partialWordMatches / queryWords.length) * 10;
      
      // Check if author contains all query words anywhere (less precise)
      let containsAllWords = true;
      queryWords.forEach(qWord => {
        if (!author.includes(qWord)) {
          containsAllWords = false;
        }
      });
      
      if (containsAllWords) return 40;
      
      // Check if author contains any query words
      let containsAnyWord = false;
      let containedWords = 0;
      queryWords.forEach(qWord => {
        if (author.includes(qWord)) {
          containsAnyWord = true;
          containedWords++;
        }
      });
      
      if (containsAnyWord) return 25 + (containedWords / queryWords.length) * 10;
      
      return 0;
    }

    // AUTHOR SEARCH IMPLEMENTATION
    async function performAuthorSearch(query, opts = {}) {
      const append = opts && opts.append === true;
      const resultDiv = opts && opts.resultDiv;
      const skipHeader = opts && opts.skipHeader === true;
      // Use Open Library authors search with name field for more precise results
      const searchUrl = `https://openlibrary.org/search/authors.json?q=name:"${encodeURIComponent(query)}" OR name:${encodeURIComponent(query)}*&limit=50`;
      try {
        const response = await fetch(searchUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const res = await response.json();
        const authors = res.docs || [];
        if (authors.length === 0) {
          if (!append) resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6"><p class="text-red-600">No authors found.</p></div>`;
          return;
        }

        // Filter and sort authors by relevance, and remove duplicates by name
        const uniqueAuthors = new Map();
        authors.forEach(author => {
          const key = (author.name || 'Unknown').toLowerCase().trim();
          if (!uniqueAuthors.has(key) || calculateRelevance(author.name, query) > calculateRelevance(uniqueAuthors.get(key).name, query)) {
            uniqueAuthors.set(key, author);
          }
        });
        
        const relevantAuthors = Array.from(uniqueAuthors.values())
          .map(author => ({
            ...author,
            relevance: calculateRelevance(author.name, query)
          }))
          .filter(author => author.relevance >= 25) // Only show reasonably relevant results
          .sort((a, b) => b.relevance - a.relevance) // Sort by relevance (highest first)
          .slice(0, 5); // Limit to top 5 authors for better UX

        if (relevantAuthors.length === 0) {
          if (!append) resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6"><p class="text-red-600">No relevant authors found for "${query}". Try a different search term.</p></div>`;
          return;
        }

        // Render author cards with enriched data
        // Clear loading when starting to show results (except when appending)
        // Note: Don't clear if container is already empty (pre-cleared in All Sources mode)
        if (!append && resultContainer.innerHTML.trim() !== '') {
          resultContainer.innerHTML = '';
        }
        
        // Add collapsible header for Open Library Author Results (only when not appending and not skipping header)
        let authorContentDiv;
        if (!append && !skipHeader) {
          const authorHeaderDiv = document.createElement('div');
          authorHeaderDiv.className = 'sticky-section bg-green-50 border-l-4 border-green-400 p-4 mb-4 cursor-pointer hover:bg-green-100 transition-colors';
          const authorContentId = `author-content-${Date.now()}`;
          authorHeaderDiv.innerHTML = `
            <div class="flex items-center justify-between">
              <div>
                <h2 class="text-lg font-semibold text-green-800 mb-1">Open Library Author Results</h2>
                <p class="text-sm text-green-600">Authors from Open Library database</p>
              </div>
              <button class="text-green-600 hover:text-green-800 text-xl font-bold" aria-label="Toggle visibility">+</button>
            </div>
          `;
          
          // Create collapsible content container for authors (initially hidden)
          authorContentDiv = document.createElement('div');
          authorContentDiv.id = authorContentId;
          authorContentDiv.className = 'sticky-content author-results-content';
          authorContentDiv.style.display = 'none'; // Start collapsed
          
          // Add simple click handler for toggle
          authorHeaderDiv.addEventListener('click', createToggleHandler(authorHeaderDiv, authorContentId));
          
          resultContainer.appendChild(authorHeaderDiv);
          resultContainer.appendChild(authorContentDiv);
        }
        
        // If using a specific result div (skipHeader mode), use that as the content container
        if (skipHeader && resultDiv) {
          authorContentDiv = resultDiv;
          // Clear skeleton loading content before adding real results
          authorContentDiv.innerHTML = '';
        }
        
        // Process relevant authors with enriched data
        const enrichedAuthorsPromises = relevantAuthors.map(author => enrichAuthorData(author));
        const enrichedAuthors = await Promise.all(enrichedAuthorsPromises);

        enrichedAuthors.forEach(author => {
          const card = document.createElement('article');
          card.className = 'bg-white rounded-lg shadow-lg p-6 mb-6 border-l-4 border-green-400 hover:shadow-xl transition-shadow';
          card.setAttribute('role', 'article');
          card.setAttribute('aria-label', `Author: ${author.name || 'Unknown'}`);
          
          const name = author.name || 'Unknown';
          const birth = author.birth_date ? ` (b. ${author.birth_date})` : '';
          const death = author.death_date ? ` - d. ${author.death_date}` : '';
          const topWorks = author.top_work ? `<div class="text-sm text-gray-700 mb-2"><strong>Notable work:</strong> ${author.top_work}</div>` : '';
          const bio = author.bio ? `<div class="text-sm text-gray-600 mt-2 leading-relaxed">${typeof author.bio === 'string' ? author.bio.substring(0, 200) + '...' : author.bio.value ? author.bio.value.substring(0, 200) + '...' : ''}</div>` : '';
          const authorPhoto = createAuthorPhotoElement(author);
          
          card.innerHTML = `
            <div class="flex items-start gap-6">
              <div class="flex-shrink-0" role="img" aria-label="Author photo">
                ${authorPhoto}
              </div>
              <div class="flex-1 min-w-0">
                <header class="mb-3">
                  <h2 class="text-2xl font-bold text-gray-900 mb-1">${name}${birth}${death}</h2>
                  ${topWorks}
                  ${bio}
                </header>
                <div class="mt-4">
                  <nav class="flex flex-wrap gap-3" aria-label="Author links">
                    <a href="https://openlibrary.org/authors/${author.key}" target="_blank" 
                       class="inline-flex items-center px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors text-sm font-medium"
                       aria-label="View ${name} on Open Library">
                      üìö Open Library Profile
                    </a>
                    <a href="https://catalog.loc.gov/vwebv/search?searchArg=${encodeURIComponent(author.name)}&searchCode=NAME" target="_blank" 
                       class="inline-flex items-center px-3 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors text-sm font-medium"
                       aria-label="Search for ${name} in Library of Congress">
                      üèõÔ∏è Library of Congress
                    </a>
                  </nav>
                </div>
                <div class="mt-4">
                  <div class="works-container" data-author-key="${author.key}">
                    <div class="flex items-center justify-between mb-2">
                      <h3 class="text-lg font-semibold text-gray-800">Works by this author</h3>
                      <div class="loading-works text-sm text-gray-500">Loading works...</div>
                    </div>
                    <div class="works-list"></div>
                  </div>
                </div>
              </div>
            </div>
          `;

          // Fetch and display author's works in an improved format
          const worksContainer = card.querySelector('.works-container');
          const worksList = card.querySelector('.works-list');
          const loadingWorks = card.querySelector('.loading-works');
          
          (async () => {
            try {
              const worksResponse = await fetch(`https://openlibrary.org/authors/${author.key}/works.json?limit=15`);
              if (!worksResponse.ok) {
                loadingWorks.textContent = 'Could not load works';
                loadingWorks.className = 'text-sm text-red-500';
                return;
              }
              
              const worksRes = await worksResponse.json();
              const works = worksRes.entries || [];
              
              loadingWorks.style.display = 'none';
              
              if (works.length === 0) {
                worksList.innerHTML = '<p class="text-gray-500 text-sm">No works found.</p>';
                return;
              }
              
              // Create a grid of works
              const worksGrid = document.createElement('div');
              worksGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-3 mt-2';
              worksGrid.setAttribute('role', 'list');
              worksGrid.setAttribute('aria-label', `Works by ${author.name}`);
              
              works.slice(0, 10).forEach((work, index) => {
                const workCard = document.createElement('div');
                workCard.className = 'bg-gray-50 rounded-md p-3 border border-gray-200 hover:bg-gray-100 transition-colors';
                workCard.setAttribute('role', 'listitem');
                
                const title = work.title || 'Untitled';
                const firstPublished = work.first_publish_date || '';
                const subjects = work.subjects ? work.subjects.slice(0, 3).join(', ') : '';
                

                
                workCard.innerHTML = `
                  <div class="space-y-2">
                        <h4 class="font-medium text-gray-900 text-sm leading-tight line-clamp-2">${title}</h4>
                        ${firstPublished ? `<p class="text-xs text-gray-600">üìÖ First published: ${firstPublished}</p>` : ''}
                        ${subjects ? `<p class="text-xs text-gray-500">üè∑Ô∏è ${subjects}</p>` : ''}
                        <div class="flex flex-wrap gap-1 mt-2">
                          <button class="search-work-btn text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 transition-colors"
                                  data-title="${title}" aria-label="Search for ${title}">
                            üîç Search
                          </button>
                          <a href="https://openlibrary.org${work.key}" target="_blank" 
                             class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded hover:bg-green-200 transition-colors"
                             aria-label="View ${title} on Open Library">
                            ÔøΩ View
                          </a>
                          ${work.ia && work.ia.length > 0 ? `
                            <a href="https://archive.org/details/${work.ia[0]}" target="_blank"
                               class="text-xs bg-orange-100 text-orange-700 px-2 py-1 rounded hover:bg-orange-200 transition-colors"
                               aria-label="Read ${title} on Internet Archive">
                              üìñ Read
                            </a>
                          ` : ''}
                        </div>
                  </div>
                `;
                
                // Add click handler for search button
                const searchBtn = workCard.querySelector('.search-work-btn');
                searchBtn.addEventListener('click', () => {
                  searchBar.value = title;
                  searchBar.dispatchEvent(new Event('change'));
                  window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                
                worksGrid.appendChild(workCard);
              });
              
              worksList.appendChild(worksGrid);
              
              // Add "show more" button if there are more works
              if (works.length > 10) {
                const showMoreBtn = document.createElement('button');
                showMoreBtn.className = 'mt-3 text-sm text-blue-600 hover:text-blue-800 underline';
                showMoreBtn.textContent = `Show ${works.length - 10} more works...`;
                showMoreBtn.addEventListener('click', () => {
                  window.open(`https://openlibrary.org/authors/${author.key}`, '_blank');
                });
                worksList.appendChild(showMoreBtn);
              }
              
            } catch (err) {
              console.error('Error fetching works:', err);
              loadingWorks.textContent = 'Error loading works';
              loadingWorks.className = 'text-sm text-red-500';
            }
          })();

          // Append to the appropriate container
          if (skipHeader && resultDiv) {
            resultDiv.appendChild(card);
          } else if (!append && authorContentDiv) {
            authorContentDiv.appendChild(card);
          } else {
            resultContainer.appendChild(card);
          }
        });

        // update result count when not appending
        if (!append && resultCount) resultCount.textContent = `${authors.length} author(s) found`;

      } catch (err) {
        console.error('Author search failed', err);
        if (!append) {
          resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6"><p class="text-red-600">Author search failed.</p></div>`;
        }
      }
    }

    // TITLE SEARCH IMPLEMENTATION
    async function performTitleSearch(query, resultDiv) {
      const olSearchUrl = `https://openlibrary.org/search.json?title=${encodeURIComponent(query)}&fields=*,availability&limit=10`;
      try {
        const response = await fetch(olSearchUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const olRes = await response.json();
        const matches = olRes.docs || [];
        
        if (matches.length === 0) {
          resultDiv.innerHTML = `<p class="text-red-600">No Open Library titles found for "${query}".</p>`;
          return;
        }

        // Clear any placeholder content
        resultDiv.innerHTML = '';

        // Create a grid for multiple title results
        const titlesGrid = document.createElement('div');
        titlesGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4';

        matches.slice(0, 9).forEach((olMatch, index) => {
          const titleCard = document.createElement('div');
          titleCard.className = 'bg-white rounded-lg shadow-md p-4 border hover:shadow-lg transition-shadow';

          const isbn = olMatch.isbn?.[0];
          const coverId = olMatch.cover_i;
          const lccn = olMatch.lccn?.[0];
          const iaId = olMatch.ia?.[0];
          const gutenbergId = olMatch.id_gutenberg?.[0];

          // Enhanced cover URL generation with multiple fallbacks
          let coverUrl = null;
          if (coverId) {
            coverUrl = `https://covers.openlibrary.org/b/id/${coverId}-M.jpg`;
          } else if (isbn) {
            coverUrl = `https://covers.openlibrary.org/b/isbn/${isbn}-M.jpg`;
          } else if (lccn) {
            coverUrl = `https://covers.openlibrary.org/b/lccn/${lccn}-M.jpg`;
          } else if (olMatch.key) {
            // Try using the work key
            const workId = olMatch.key.replace('/works/', '');
            coverUrl = `https://covers.openlibrary.org/b/olid/${workId}-M.jpg`;
          }

          // If still no cover, try title-based search
          if (!coverUrl && olMatch.title) {
            const cleanTitle = olMatch.title.split(':')[0].split('/')[0].trim();
            coverUrl = `https://covers.openlibrary.org/b/title/${encodeURIComponent(cleanTitle)}-M.jpg`;
          }

          const locLink = isbn
            ? `https://catalog.loc.gov/vwebv/search?searchArg=${isbn}&searchCode=ISBN`
            : lccn
              ? `https://id.loc.gov/resources/bibs/${lccn}`
              : null;

          // Create cover element with improved fallback logic
          const coverHtml = coverUrl ? `
            <div class="flex-shrink-0 text-center mb-3">
              <img src="${coverUrl}" alt="Cover for ${olMatch.title || 'Unknown Title'}"
                   class="w-24 h-36 object-cover rounded shadow-md mx-auto"
                   onload="this.style.display='block'; this.nextElementSibling.style.display='none';"
                   onerror="handleCoverError(this);"
                   style="display: block;">
              <div class="w-24 h-36 bg-gradient-to-br from-gray-200 to-gray-300 rounded flex items-center justify-center text-gray-500 text-xs mx-auto border border-gray-200" style="display: none;">
                <div class="text-center">
                  <div class="text-lg mb-1">üìñ</div>
                  <div>No Cover</div>
                </div>
              </div>
            </div>
          ` : `
            <div class="w-24 h-36 bg-gradient-to-br from-gray-200 to-gray-300 rounded flex items-center justify-center text-gray-500 text-xs mx-auto mb-3 border border-gray-200">
              <div class="text-center">
                <div class="text-lg mb-1">üìñ</div>
                <div>No Cover</div>
              </div>
            </div>
          `;

          titleCard.innerHTML = `
            ${coverHtml}
            <div class="space-y-2">
              <h3 class="font-semibold text-gray-900 text-sm leading-tight line-clamp-2">
                ${olMatch.title || 'Unknown Title'}
              </h3>
              <p class="text-xs text-gray-600">
                <strong>Author:</strong> ${olMatch.author_name?.[0] || 'Unknown'}
              </p>
              <p class="text-xs text-gray-600">
                <strong>Published:</strong> ${olMatch.first_publish_year || 'N/A'}
              </p>
              ${olMatch.subject ? `
                <p class="text-xs text-gray-500">
                  <strong>Genre:</strong> ${olMatch.subject.slice(0, 2).join(', ')}
                </p>
              ` : ''}
              <div class="flex gap-1 mt-3">
                <a href="https://openlibrary.org${olMatch.key}" target="_blank" 
                   class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 transition-colors">
                  üìö Open Library
                </a>
                ${locLink ? `
                  <a href="${locLink}" target="_blank" 
                     class="text-xs bg-gray-100 text-gray-700 px-2 py-1 rounded hover:bg-gray-200 transition-colors">
                    üèõÔ∏è LoC
                  </a>
                ` : ''}
                ${iaId ? `
                  <a href="https://archive.org/details/${iaId}" target="_blank" 
                     class="text-xs bg-green-100 text-green-700 px-2 py-1 rounded hover:bg-green-200 transition-colors">
                    üìñ Archive
                  </a>
                ` : ''}
              </div>
            </div>
          `;

          titlesGrid.appendChild(titleCard);
        });

        resultDiv.appendChild(titlesGrid);

        // Add "Show more" link if there are more results
        if (matches.length > 9) {
          const showMoreDiv = document.createElement('div');
          showMoreDiv.className = 'mt-4 text-center';
          showMoreDiv.innerHTML = `
            <a href="https://openlibrary.org/search?title=${encodeURIComponent(query)}" target="_blank"
               class="text-blue-600 hover:text-blue-800 underline text-sm">
              View all ${matches.length} results on Open Library ‚Üí
            </a>
          `;
          resultDiv.appendChild(showMoreDiv);
        }

      } catch (err) {
        console.error('Title search failed:', err);
        resultDiv.innerHTML = `<p class="text-red-600">Title search failed. Please try again.</p>`;
      }
    }

    // LIBRARY OF CONGRESS SEARCH IMPLEMENTATION
    async function performLibraryOfCongressSearch(query, opts = {}) {
      const append = opts && opts.append === true;
      const resultDiv = opts && opts.resultDiv;
      const titlesOnly = opts && opts.titlesOnly === true;
      const skipHeader = opts && opts.skipHeader === true;
      
      try {
        // Use Library of Congress JSON API
        const locSearchUrl = `https://www.loc.gov/search/?q=${encodeURIComponent(query)}&fo=json&c=150`;
        const response = await fetch(locSearchUrl);
        
        if (!response.ok) {
          throw new Error(`LoC API error: ${response.status}`);
        }
        
        const data = await response.json();
        const results = data.results || [];
        
        if (results.length === 0) {
          if (resultDiv) {
            resultDiv.innerHTML = `<p class="text-red-600">No Library of Congress results found for "${query}".</p>`;
          } else if (!append) {
            resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6">
              <p class="text-red-600">No Library of Congress results found for "${query}".</p>
            </div>`;
          }
          return;
        }
        
        // If using a specific result div, work with that instead of resultContainer
        const targetContainer = resultDiv || resultContainer;
        
        // Clear container only if not appending and not using a specific resultDiv
        if (!append && !resultDiv) targetContainer.innerHTML = '';
        
        // Create section header for LoC results (only when not skipping header)
        let headerDiv, contentDiv;
        if (!skipHeader) {
          // Simple condition: create header only when not appending OR when in standalone mode
          if (!append) {
            headerDiv = document.createElement('div');
            headerDiv.className = 'sticky-section bg-blue-50 border-l-4 border-blue-400 p-4 mb-4 cursor-pointer hover:bg-blue-100 transition-colors';
            const headerTitle = titlesOnly ? 'Library of Congress Titles' : 'Library of Congress Results';
            const headerId = `loc-header-${Date.now()}`;
            const contentId = `loc-content-${Date.now()}`;
            headerDiv.innerHTML = `
              <div class="flex items-center justify-between">
                <div>
                  <h2 class="text-lg font-semibold text-blue-800 mb-1">${headerTitle}</h2>
                  <p class="text-sm text-blue-600">Direct from the Library of Congress catalog</p>
                </div>
                <button class="text-blue-600 hover:text-blue-800 text-xl font-bold" aria-label="Toggle visibility">+</button>
              </div>
            `;
            
            // Create collapsible content container
            contentDiv = document.createElement('div');
            contentDiv.id = contentId;
            contentDiv.className = 'sticky-content loc-results-content';
            
            // Add simple click handler for toggle
            headerDiv.addEventListener('click', createToggleHandler(headerDiv, contentId));
            
            if (resultDiv) {
              resultDiv.appendChild(headerDiv);
              resultDiv.appendChild(contentDiv);
            } else {
              targetContainer.appendChild(headerDiv);
              targetContainer.appendChild(contentDiv);
            }
          }
        }
        
        // When skipHeader is true, use the provided resultDiv as the content container
        if (skipHeader && resultDiv) {
          contentDiv = resultDiv;
          // Clear skeleton loading content before adding real results
          contentDiv.innerHTML = '';
        }
        
        // Process and display LoC results
        results.slice(0, 10).forEach(item => {
          const card = document.createElement('div');
          card.className = 'bg-white rounded-lg shadow p-6 mb-4 border-l-4 border-blue-200';
          
          const title = item.title || 'No title available';
          // Fix: LoC API uses 'contributor' field, not 'contributors'
          const creators = item.contributor && item.contributor.length > 0 
            ? item.contributor.slice(0, 3).join(', ') 
            : (item.author && item.author.length > 0
              ? item.author.slice(0, 3).join(', ')
              : 'Unknown author');
          const date = item.date || 'Date unknown';
          const description = item.description ? item.description.slice(0, 200) + '...' : '';
          const subjects = item.subject ? item.subject.slice(0, 5).join(', ') : '';
          const locUrl = item.url || '#';
          
          // Try to get cover image from various sources
          let coverUrl = null;
          if (item.isbn && item.isbn.length > 0) {
            coverUrl = `https://covers.openlibrary.org/b/isbn/${item.isbn[0]}-L.jpg`;
          } else if (item.lccn && item.lccn.length > 0) {
            coverUrl = `https://covers.openlibrary.org/b/lccn/${item.lccn[0]}-L.jpg`;
          } else {
            // Fallback: try to search Open Library by title and author
            const searchTitle = title.split(':')[0].split('/')[0].trim(); // Clean up title
            const searchAuthor = creators !== 'Unknown author' ? creators.split(',')[0].trim() : '';
            if (searchTitle) {
              coverUrl = `https://covers.openlibrary.org/b/title/${encodeURIComponent(searchTitle)}-L.jpg`;
            }
          }
          
          // Debug: Log the item structure to see available fields
          console.log('LoC item structure:', item);
          
          const coverHtml = coverUrl ? `
            <div class="flex-shrink-0 mr-6">
              <img src="${coverUrl}" alt="Book cover for ${title}" 
                   class="w-32 h-48 object-cover rounded-lg shadow-md"
                   onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
              <div class="w-32 h-48 bg-gray-200 rounded-lg flex items-center justify-center text-gray-500 text-sm" style="display: none;">
                No Cover
              </div>
            </div>
          ` : '';
          
          card.innerHTML = `
            <div class="flex ${coverUrl ? 'items-start' : ''}">
              ${coverHtml}
              <div class="flex-1">
                <div class="mb-3">
                  <h3 class="text-xl font-bold text-gray-900 mb-2">${title}</h3>
                  <div class="text-gray-700 space-y-1">
                    <p><strong>Creator(s):</strong> ${creators}</p>
                    <p><strong>Date:</strong> ${date}</p>
                    ${description ? `<p><strong>Description:</strong> ${description}</p>` : ''}
                    ${subjects ? `<p><strong>Subjects:</strong> ${subjects}</p>` : ''}
                  </div>
                </div>
                <div class="flex gap-2 mt-4">
                  <a href="${locUrl}" target="_blank" 
                     class="inline-block bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors">
                    View in Library of Congress
                  </a>
                  ${item.resources && item.resources.find(r => r.pdf) ? 
                    `<a href="${item.resources.find(r => r.pdf).url}" target="_blank" 
                       class="inline-block bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors">
                      View PDF
                    </a>` : ''}
                </div>
              </div>
            </div>
          `;
          
          // Append cards to the appropriate container
          if (contentDiv) {
            contentDiv.appendChild(card);
          } else if (resultDiv) {
            resultDiv.appendChild(card);
          } else {
            targetContainer.appendChild(card);
          }
        });
        
        // Update result count
        const resultCount = document.getElementById('resultCount');
        if (resultCount && !append && !resultDiv) {
          resultCount.textContent = `${results.length} Library of Congress result(s) found`;
        }
        
      } catch (err) {
        console.error('Library of Congress search failed:', err);
        if (resultDiv) {
          resultDiv.innerHTML = `<p class="text-red-600">Library of Congress search failed. Please try again.</p>`;
        } else if (!append) {
          resultContainer.innerHTML = `<div class="bg-white rounded-lg shadow p-6 mb-6">
            <p class="text-red-600">Library of Congress search failed. Please try again.</p>
          </div>`;
        }
      }
    }
  </script>
  
  <script>
    // Back to Top Button Functionality
    const backToTopBtn = document.getElementById('backToTop');
    
    // Show/hide button based on scroll position
    window.addEventListener('scroll', () => {
      if (window.pageYOffset > 300) { // Show button after scrolling 300px
        backToTopBtn.style.display = 'flex';
      } else {
        backToTopBtn.style.display = 'none';
      }
    });
    
    // Smooth scroll to top when button is clicked
    backToTopBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  </script>
</body>
</html>